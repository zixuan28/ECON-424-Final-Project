---
title: "Econ 424 Project Group 7"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

```{r, echo = FALSE}
options(digits=3, width=70)
# load packages
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(IntroCompFinR))
suppressPackageStartupMessages(library(PerformanceAnalytics))
suppressPackageStartupMessages(library(quantmod))
suppressPackageStartupMessages(library(boot))
suppressPackageStartupMessages(library(corrplot))
suppressPackageStartupMessages(library(xtable))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(lubridate))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gridExtra))

resetPar = par()
```


# Data

Choose 4-6 assets that represent e.g. the overall equity market behavior for different countries or regions of the world or some other grouping of indexes. Below are some examples
* S&P/ASX 200 is a commonly used stock market index for Australia.  
* Commodity indices:www.spglobal.com/spdji/en/indices/commodities/sp-gsci/#data
* Real estate indexes and others by MSCI: https://www.msci.com/our-solutions/indexes/real-estate-indexes
* Vanguard index funds: https://investor.vanguard.com/investment-products/list/all?managementstyle=index
* https://www.schwab.com/etfs/types/currency-etfs

Exactly which set of assets you pick is up to your group, but please motivate your choice.  You may also want to explore ETFs vs. Mutual Funds.  Indices are more diversified so tend to be easier to work with than individual stocks.

The template uses the following 5 assets over 10 years: Change the symbols to your own choices, and expand the time period to what makes sense to you (again, motivate/explain your choice.)

1. US Stocks. Vanguard Total Stock Market ETF (VTI)
2. Municipal Bonds. Vanguard Tax-Exempt Bond Index ETF (VTEB)
3. Foreign Developed Stocks. Vanguard FTSE Developed Markets ETF (VEA)
4. Emerging market stocks. Vanguard FTSE Emerging Markets ETF (VWO)
5. Dividend Growth Stocks. Vanguard Dividend Appreciation ETF (VIG)
(a possible one: Goldman Sachs Physical Gold ETF (AAAU)

Information on these funds is available on the [Yahoo! finance site](http://finance.yahoo.com/) After typing in the sticker symbol and retrieving the quote data, choose Profile to get a summary of the fund. Please review each fund before doing any of the analysis below.

Data for the project are downloaded automatically from Yahoo! and consist of closing price data on 5 Vanguard ETFs:

```{r, echo=FALSE}
# retrieve data for questions
last.date = as.Date("2023-12-31")
# last.date = Sys.Date()
first.date = last.date - years(10)
project.symbols = c("EWS","EWY","EWT","EWH")
project.prices <- 
  getSymbols(project.symbols, src = 'yahoo', 
             from = as.character(first.date), 
             to = as.character(last.date),
             auto.assign = TRUE, 
             warnings = FALSE) %>% 
  map(~Ad(get(.))) %>% 
  reduce(merge) %>%
  `colnames<-`(project.symbols)
projectPrices = to.monthly(project.prices, OHLC=FALSE)  # Group 7 you should continue to use daily data and skip this
```

```{r, echo=FALSE}
# calculate simple returns
projectReturns = na.omit(Return.calculate(projectPrices, method = "discrete"))
ret.mat = coredata(projectReturns)
```


# Organization of Results

As in the homework assignments, summarize your R work in an R Markdown file.

# Presentation Focus

Please provide a formal write-up of the project questions for your presentation (see end of file). Your presentation should consist of:

1. An executive summary, which gives a brief summary of the main results and key insights using bullet points

2. Sections that summarize the results of your statistical analysis by topic (see below) - given the time constraint, you want to focus on patterns that illustrate the key messages mentioned in the summary.  Do not present EVERYTHING; it will make a very boring presentation: focus on 3-5 main messages.

Submit the full writeup with R-output, and present only selected parts of it for your presentation.  

# Analysis of Questions  

Here, you will create R code to do the analysis for the project. Note that should adjust numbers according to your data and sample period, including the risk free rate, targeted returns..etc.

## Prices and Returns

**For each ETF or assets, compute time plots of monthly prices and simple returns and comment. (e.g Are there any unusually large or small returns? Can you identify any news events that may explain these unusual values?  are they stationary?) **

```{r, echo = FALSE}
# plot(projectPrices, multi.panel=TRUE, 
#      yaxis.same=FALSE, main="Monthly Prices on 5 Vanguard ETFs", lwd=2, col="blue")
grid.arrange(
  autoplot(projectPrices[, "EWS"]),
  autoplot(projectPrices[, "EWY"]),
  autoplot(projectPrices[, "EWH"]),
  autoplot(projectPrices[, "EWT"]),
  nrow=3
)
```



**Q: Give a plot showing the growth of $1 in each of the funds over the five year period (recall, this is called an "equity curve"). Which fund gives the highest future value? Are you surprised?**

```{r Equity-Curve}
project.gret = 1+projectReturns
equity = cumprod(project.gret)
colors = c("blue", "red", "green", "orange")

matplot(equity, type="l", col=colors, lwd=2, lty=1, xlab="Days", ylab="Equity Value", main="Simulated Equity Curve")
legend("topleft", legend = c(project.symbols), col = colors, lty=1, lwd=2)
```

## Sample Statistics

**Create four panel diagnostic plots containing histograms, boxplots, qq-plots, and SACFs for each return series and comment. Do the returns look normally distributed? Are there significant outliers in the data? Is there any evidence of linear time dependence?**
```{r}
projectReturns <- na.omit(diff(log(projectPrices)))
# Function to create a four-panel diagnostic plot
fourPanelPlot <- function(return_series, title) {
  par(mfrow = c(2, 2))  # 2x2 layout for four plots
  
  # Histogram with normal density curve
  hist(return_series, probability = TRUE, col = "lightblue", main = paste(title, "Monthly Returns"), xlab = title)
  lines(density(return_series, na.rm = TRUE), col = "black", lwd = 2)
  
  # Boxplot
  boxplot(return_series, horizontal = TRUE, col = "lightblue", main = "Boxplot")
  
  # Normal Q-Q Plot
  qqnorm(return_series, main = "Normal Q-Q Plot", col = "blue")
  qqline(return_series, col = "black", lwd = 2)
  
  # ACF Plot
  acf(return_series, main = "ACF", col = "black")
}
fourPanelPlot(projectReturns[, "EWS"], "EWS")
fourPanelPlot(projectReturns[, "EWY"], "EWY")
fourPanelPlot(projectReturns[, "EWT"], "EWT")
fourPanelPlot(projectReturns[, "EWH"], "EWH")
```
Interpretation:
"The histograms and normal Q-Q plots suggest that the returns are approximately normal but with slight deviations. EWS, EWY, EWT, and EWH all exhibit fat tails, meaning extreme values occur more frequently than expected under a normal distribution. The Q-Q plots show noticeable deviations at the tails, reinforcing the presence of heavy tails and confirming non-normality. The distributions appear roughly symmetric with no significant skewness.

Boxplots indicate a few outliers in each series, particularly in EWS and EWT. These outliers are present on both ends of the distribution, suggesting occasional extreme positive and negative returns. However, their frequency is not excessive, indicating that while the data contains some anomalies, it remains relatively well-behaved.

The autocorrelation function (ACF) plots for all four return series reveal that only the first lag exhibits a small, significant autocorrelation. Beyond the first lag, the autocorrelations fall within the blue confidence bands, meaning there is no strong evidence of persistent time dependence. This suggests that returns are largely independent over time, aligning with the efficient market hypothesis.

Overall, the returns do not strictly follow a normal distribution but are roughly symmetric with fat tails. While some outliers exist, they are not extreme enough to cause major concerns. The lack of significant autocorrelation beyond the first lag indicates no strong linear dependence, suggesting that past returns do not strongly predict future returns."

**Create a plot showing the distributions of all of the assets in one graph.**
```{r}
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(reshape2))
# Convert return data to long format for ggplot
returns_long <- melt(as.data.frame(projectReturns))

# Create density plot with all assets in one graph
ggplot(returns_long, aes(x = value, color = variable, fill = variable)) + 
  geom_density(alpha = 0.3) + 
  ggtitle("Return Distributions of All Assets") +
  xlab("Log Returns") + 
  ylab("Density") +
  theme_minimal()
```

# Sample Statistics

**Compute univariate descriptive statistics (mean, variance, standard deviation, skewness, kurtosis, quantiles) for each return series and comment.**
```{r}
# Compute descriptive statistics
muhat.vals = colMeans(projectReturns, na.rm = TRUE)
var.vals = apply(projectReturns, 2, var, na.rm = TRUE)
sd.vals = apply(projectReturns, 2, sd, na.rm = TRUE)
skew.vals = apply(projectReturns, 2, skewness, na.rm = TRUE)
ekurt.vals = apply(projectReturns, 2, kurtosis, na.rm = TRUE)

# Combine statistics into a matrix
stats.mat = rbind(muhat.vals, var.vals, sd.vals, skew.vals, ekurt.vals)

# Assign row names
rownames(stats.mat) = c("Mean", "Variance", "Std Dev", "Skewness", "Excess Kurtosis")

# Print the statistics table
stats.mat

# Compute quantiles for each asset
quantiles.vals = apply(projectReturns, 2, quantile, probs = c(0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99), na.rm = TRUE)

# Print quantile statistics
quantiles.vals
```

**Q: Which countries or assets have the highest and lowest average return? Which funds have the highest and lowest standard deviation? How about their skewness and excess kurtosis?  For which assets is the assumption of normal distribution the most appropriate?** 


**Make an x-y plot with the standard deviations on the x-axis and the means on the y-axis. Comment on the risk-return relationship you see.**
```{r Risk-Return-Plot}
cex.val = 2

plot(sd.vals, muhat.vals, pch = 16, col = "blue", ylim=c(0, max(muhat.vals)+0.001), xlim=c(min(sd.vals)-.001, max(sd.vals)), xlab = "Portfolio Risk", ylab = "Expected Portfolio Return", main = "Risk-Return Tradeoff")
text(sd.vals, muhat.vals, project.symbols, pos=3)
```

**Compute estimated standard errors and form $95\%$ confidence intervals for the the estimates of the mean and standard deviation. Arrange these values nicely in a table. Are these means and standard deviations estimated very precisely? Which estimates are more precise: the estimated means or standard deviations? for which assets?**
```{r EstError-CI}
n.obs = nrow(projectReturns)
seMuhat = sd.vals/sqrt(n.obs)
seSD.vals = sd.vals/sqrt(2*n.obs)
# 95% Confidence Interval
mu.CI.top = muhat.vals + 2*seMuhat
mu.CI.bot = muhat.vals - 2*seMuhat
mu.CI.width = mu.CI.top - mu.CI.bot
se.CI.top = sd.vals + 2*seSD.vals
se.CI.bot = sd.vals - 2*seSD.vals
se.CI.width = se.CI.top - se.CI.bot

cbind(muhat.vals, seMuhat, mu.CI.top, mu.CI.bot, mu.CI.width)
cbind(sd.vals, seSD.vals, se.CI.top, se.CI.bot, se.CI.width)

```
Overall, the means do not seem to be precisely estimated at all as every estimated standard error for the mean is larger than the estimated mean with the exception of Taiwain (EWT). The standard error for EWT is still over half that of the estimated mean which shows its still not a great/precise estimate. However, the standard deviations seem to be much more precise than the means. The estimated standard errors are all much smaller than the estimated values and the 95% confidence interval is still roughly 1/5th that of the estimated standard deviation. This shows that the historical data gives better insights into the risk associated with these assets than the expected return.

**Using a monthly risk free rate equal to e.g.0.0004167 per month (which corresponds to a continuously compounded annual rate of 0.5%), compute Sharpe's slope/ratio for each asset. Use the bootstrap to calculate estimated standard errors for the Sharpe ratios. Arrange these values nicely in a table.  Note: here you should look at what a sensible monthly risk-free rate is for the choice of your sample period, e.g. https://www.macrotrends.net/2518/1-month-libor-rate-historical-chart**
```{r SharpeRatios}
# Risk Free rate 
# Risk free rate was determined from link above and taking the average yearly yield from 2013 to 2020
rf.ann = 0.89
risk.free = 0.0007385
project.sharpe = (muhat.vals - risk.free)/sd.vals
project.sharpe
```

**Q: Which country/region (asset) has the highest Sharpe slope?**
EWT (ETF for Taiwan) has the highest Sharpe slope at 0.13193.

Next, we use the bootstrap to compute estimated SEs for the Sharpe ratios. First, we create a function to compute the Sharpe ratios to be passed to the `boot()` function and then we create another function to pull out the boostrap SEs and 95% confidence intervals. We run these functions and put the results in the following table:

```{r, echo=FALSE}
## Is this right?
sharpeRatio.boot = function(x, idx, risk.free) {
  muhat = mean(x[idx])
  sigmahat = sd(x[idx])
  sharpeRatio = (muhat - risk.free)/sigmahat
  sharpeRatio
}
computeSEconfintSharpe = function(x, risk.free) {
  Sharpe.boot = boot(x, statistic=sharpeRatio.boot, R=999, risk.free=risk.free)
  Sharpe.hat = Sharpe.boot$t0
  SE.Sharpe = sd(Sharpe.boot$t)
  CI.Sharpe = boot.ci(Sharpe.boot, conf = 0.95, type="norm")$normal
  CI.Sharpe = CI.Sharpe[-1]
  ans = c(Sharpe.hat, SE.Sharpe, CI.Sharpe)
  names(ans) = c("Sharpe", "SE", "LCL (0.95)", "UCL (0.95)")
  return(ans)
}
set.seed(123)
Sharpe.boot.EWS = computeSEconfintSharpe(projectReturns[, "EWS", drop=FALSE], risk.free)
Sharpe.boot.EWY = computeSEconfintSharpe(projectReturns[, "EWY", drop=FALSE], risk.free)
Sharpe.boot.EWT = computeSEconfintSharpe(projectReturns[, "EWT", drop=FALSE], risk.free)
Sharpe.boot.EWH = computeSEconfintSharpe(projectReturns[, "EWH", drop=FALSE], risk.free)

Sharpe.mat = rbind(Sharpe.boot.EWS,
                Sharpe.boot.EWY,
                Sharpe.boot.EWT,
                Sharpe.boot.EWH)
rownames(Sharpe.mat) = colnames(projectReturns)
kable(Sharpe.mat)
```

**Q: Are the Sharpe slopes estimated precisely?**
The sharpe slopes estimated do not seem to be precise as all of the standard errors are very large. Only Taiwan's standard error is smaller than the estimated sharpe ratio, but only by 0.004.

**Convert the monthly sample means into annual estimates by multiplying by 12 and convert the monthly sample SDs into annual estimates by multiplying by the square root of 12. Comment on the values of these annual numbers. Using these values, compute annualized Sharpe ratios. Are the asset rankings the same as with the monthly Sharpe ratios?**
```{r MonthlyToAnnual}
muhat.vals_yr = muhat.vals * 12
sd.vals_yr = sd.vals * sqrt(12)
musd.ann = rbind(muhat.vals, muhat.vals_yr, sd.vals, sd.vals_yr)
rownames(musd.ann) = c("Monthly Expected Mean","Annual Expected Mean","Monthly std dev", "Annual std dev")
musd_yr = rbind(muhat.vals_yr, sd.vals_yr)
rownames(musd_yr) = c("annual expected mean", "annual std dev")
musd.ann

# Annualized Sharpe Ratios
## May need to adjust the risk free rates and re-run the numbers
ann.sharpe = (muhat.vals_yr - rf.ann)/sd.vals_yr
project.sharpe
ann.sharpe
```
The asset's sharpe ratios do not have the same ranking as the monthly sharpe ratios


**Assuming you get the average annual return every year for 10 years, how much would $1 grow to after 5 years? (Remember, the annual return you compute is a cc annual return).**
```{r 5yr-ROI}
v0 = 1
# cc returns = arithemetic mean
fiveyr.er = v0*exp(muhat.vals_yr * 5)
tenyr.er = v0* exp(muhat.vals_yr * 10)

fiveyr.er
tenyr.er
```

**Compute and plot all pair-wise scatterplots between your assets. Briefly comment on any relationships you see.**
```{r Pairwise-Scatter}
pairs(coredata(projectReturns),pch=16, cex=1.25, cex.axis=1.25)
```
All of the assets seem to have an overall strong linear relationship between themselves. This likely means that all four assets are correlated with each other.

**Compute the sample covariance matrix of the returns on your assets and comment on the direction of linear association between the asset returns.**
```{r Covariance matrix}
cov(projectReturns)
```
All assets seem to have a positive linear relationship with each other. It's likely that all of the assets have a strong covariant relationship.

**Compute the sample correlation matrix of the returns on your assets and plot this correlation matrix using the R corrplot package function `corrplot.mixed()`. Which assets are most highly correlated?  Which are least correlated? Based on the estimated correlation values do you think diversification will reduce risk with these assets?**
```{r Correlation-Matrix}
corrplot.mixed(cor(projectReturns), lower="number", upper="ellipse")
```
Taiwan (EWT) and Korea (EWY) are the most correlated assets while Korea and Hong Kong are the least correlated assets. Overall each asset is still has a decent amount of correlation between each other which will mean that there will be less benefits from diversification.

## Value-at-Risk Calculations

**Assume that you have $100,000 to invest starting at Dec 31, 2023.  For each asset, determine the 1\% and 5\% normal value-at-risk of the $100,000 investment over a one month investment horizon based on the normal distribution using the estimated means and variances of your assets.  Which assets have the highest and lowest VaR values?**
```{r VaR-EstCalculations}
## VaR values for 1% and 5% using estimate mu and sd values
# 5% VaR
w0 = 100000
quantiles.vals15 = quantiles.vals[1:2,] * w0
quantiles.vals15
```
Based on the normal distribution using the estimated means and variances of our assets EWY (Korea) has the highest 1% VaR while EWS (Singapore) has the lowest VaR for 1%. For 5% EWS also has the least VaR while Hong Kong (EWH) has the highest.

**Use the bootstrap to compute estimated standard errors and 95% confidence intervals for your 1\% and 5\% VaR estimates. Create a table showing the 1\% and 5\% VaR estimates along with the bootstrap standard errors and 95% confidence intervals (code provided).  Looking at these results, comment on the precision of your VaR estimates (which assets are riskier..etc.) **


Here, we write functions to compute VaR and extract bootstrap SEs and 95\% CIs, and we use these functions to compute the $5\%$ and $1\%$ normal VaR estimates and their boostrap SEs and 95\% CIs. The following tables summarizes the results:

```{r, echo=FALSE}
Value.at.Risk = function(x, p=0.05, w=100000, 
                         method=c("normal", "empirical"),
                         return.type=c("cc", "simple")) {
	method=method[1]
  return.type=return.type[1]
  x = as.matrix(x)
  if (method == "normal") {
	  q = apply(x, 2, mean) + apply(x, 2, sd)*qnorm(p)
  } else {    
    q = apply(x, 2, quantile, p)
  }
  if (return.type == "simple") {
    VaR = q*w
  } else {
	  VaR = (exp(q) - 1)*w
  }
	return(VaR)
}

ValueAtRisk.boot = function(x, idx, p=0.05, w=100000,
                            method=c("normal", "empirical"),
                            return.type=c("cc", "simple")) {
  method = method[1]
  return.type = return.type[1]
  if (method == "normal") {
	  q = mean(x[idx]) + sd(x[idx])*qnorm(p)
  } else {
    q = quantile(x[idx], p)
  }
  if (return.type == "cc") {
	  VaR = (exp(q) - 1)*w
  } else {
    VaR = q*w
  }
	VaR
}
computeSEconfintVaR = function(x, p=0.05, w=100000,
                               method=c("normal", "empirical"),
                               return.type=c("cc", "simple")) {
  VaR.boot = boot(x, statistic=ValueAtRisk.boot, p=p, R=999)
  VaR.hat = VaR.boot$t0
  SE.VaR = sd(VaR.boot$t)
  CI.VaR = boot.ci(VaR.boot, conf = 0.95, type="norm")$normal
  CI.VaR = CI.VaR[-1]
  ans = c(VaR.hat, SE.VaR, CI.VaR)
  names(ans) = c("VaR.05", "SE", "LCL (0.95)", "UCL (0.95)")
  return(ans)
}
set.seed(123)
VaR.boot.EWS = computeSEconfintVaR(projectReturns[, "EWS", drop=FALSE])
VaR.boot.EWY = computeSEconfintVaR(projectReturns[, "EWY", drop=FALSE])
VaR.boot.EWT = computeSEconfintVaR(projectReturns[, "EWT", drop=FALSE])
VaR.boot.EWH = computeSEconfintVaR(projectReturns[, "EWH", drop=FALSE])

VaR.mat = rbind(VaR.boot.EWS,
                VaR.boot.EWY,
                VaR.boot.EWT,
                VaR.boot.EWH)
                
rownames(VaR.mat) = colnames(projectReturns)
kable(VaR.mat)
```

* The normal and empirical VaR values are close? not close?  
There are differences between the normal and empirical VaR values which likely indicates that a normal distribution does not accurately predict risk for an asset. For EWS the 5% normal VaR may be overestimating risk while underestimating risk for 1%. For EWY the normal model seems to underestimate risk at both levels. For EWT and EWH show that the normal distribution does not accurately show extreme losses.


```{r, echo=FALSE}
set.seed(123)
VaR.boot.EWS.01 = computeSEconfintVaR(projectReturns[, "EWS", drop=FALSE], p=0.01)
VaR.boot.EWY.01 = computeSEconfintVaR(projectReturns[, "EWY", drop=FALSE], p=0.01)
VaR.boot.EWT.01 = computeSEconfintVaR(projectReturns[, "EWT", drop=FALSE], p=0.01)
VaR.boot.EWH.01 = computeSEconfintVaR(projectReturns[, "EWH", drop=FALSE], p=0.01)

VaR.mat.01 = rbind(VaR.boot.EWS.01,
                VaR.boot.EWY.01,
                VaR.boot.EWT.01,
                VaR.boot.EWH.01)
                
rownames(VaR.mat.01) = colnames(projectReturns)
colnames(VaR.mat.01)[1] = "VaR.01"
kable(VaR.mat.01)
```


* SAMPLE SUMMARY: VWO has the highest 5\% normal VaR values at -\$8,180 and VETB has the lowest at -\$2,414. The bootstrap SE values are fairly small (about 6-7 times smaller than the VaR values) and the confidence intervals are not too wide...etc.

* The rankings are the same for the 1\% VaR values: VWO has the highest VaR at -\$11,429, and VTEB has the lowest at -\$3,468. The bootstrap standard errors are about 8-9 times smaller than the VaR estimate2.

Unsurprisingly, EWY has the highest amount of risk for both 5% and 1% at $9940 and $13820 respectively. The lowest VaR is EWT at $7871 and $11241. The bootstrap SE values are roughly 10 times smaller than the VaR values and the confidence intervals are not too wide, but still likely wider than what would be prefered.


**Repeat the VaR analysis (but skip the bootstrapping and the annualized VaR calculation), but this time use the empirical 1% and 5% quantiles of the return distributions (which do not assume a normal distribution - this method is often called historical simulation). How different are the results from those based on the normal distribution?**


**codes are provided but please explain how the two differ computationally in your presentation. **
The 24-month rolling means are shown below:

```{r, echo=FALSE}
roll.muhat = rollapply(projectReturns, width=24, by=1, 
                       by.column=TRUE, FUN=mean, 
                       align="right")
plot(na.omit(roll.muhat), main="24-month rolling estimates of mean", multi.panel=FALSE, lwd=2,
col=c("black", "red", "green", "blue", "purple"), lty=c("solid", "solid", "solid", "solid", "solid"),
major.ticks="years", grid.ticks.on="years", legend.loc = "topright")
```


The rolling volatilities are:

```{r, echo=FALSE}
roll.sigmahat = rollapply(projectReturns, width=24, by=1, 
                          by.column=TRUE, FUN=sd, 
                          align="right")
plot(na.omit(roll.sigmahat), main="24-month rolling estimates of volatility", multi.panel=FALSE, lwd=2,
col=c("black", "red", "green", "blue", "purple"), lty=c("solid", "solid", "solid", "solid", "solid"),
major.ticks="years", grid.ticks.on="years", legend.loc = "bottomleft")
```

## Rolling Sample Statistics

**Compute and plot the 24-month rolling estimates of the mean and volatility for each of the 5 ETFs. Plot the rolling means, volatilities and returns on the same graph for each asset. Does the assumption of covariance stationarity look reasonable for your data? (code provided)  describe what you observe.  Does COVID show up in the data?**

The 24-month rolling means are shown below:

```{r, echo=FALSE}
roll.muhat = rollapply(projectReturns, width=24, by=1, 
                       by.column=TRUE, FUN=mean, 
                       align="right")
plot(na.omit(roll.muhat), main="24-month rolling estimates of mean", multi.panel=FALSE, lwd=2,
col=c("black", "red", "green", "blue", "purple"), lty=c("solid", "solid", "solid", "solid", "solid"),
major.ticks="years", grid.ticks.on="years", legend.loc = "topright")
```

The rolling volatilities are:

```{r, echo=FALSE}
roll.sigmahat = rollapply(projectReturns, width=24, by=1, 
                          by.column=TRUE, FUN=sd, 
                          align="right")
plot(na.omit(roll.sigmahat), main="24-month rolling estimates of volatility", multi.panel=FALSE, lwd=2,
col=c("black", "red", "green", "blue", "purple"), lty=c("solid", "solid", "solid", "solid", "solid"),
major.ticks="years", grid.ticks.on="years", legend.loc = "bottomleft")
```

## Historical performance

```{r, echo=FALSE}
chart.CumReturns(projectReturns, main="Example data",
                 wealth.index = TRUE, legend.loc = "topleft")
```

* Starbucks performed best over the full sample but Microsoft was best before the dot-com bust

## Estimated inputs to portfolio theory: full sample

```{r}
nobs = nrow(projectReturns)
muhat.vals = colMeans(projectReturns)
sigmahat.vals = apply(projectReturns,2,sd)
cov.mat = var(projectReturns)
cor.mat = cor(projectReturns)
```

Full sample mean values

```{r}
muhat.vals
```

Full sample volatility values

```{r}
sigmahat.vals
```

Full sample correlation matrix

```{r}
cor.mat
```

## Risk-return tradeoff: full sample

```{r}
plot(sigmahat.vals, muhat.vals,  
     ylim=c(0, 0.02), xlim=c(0, 0.1), 
     ylab=expression(mu[p]), xlab=expression(sigma[p]), 
     pch=16, col="blue", cex=1, cex.lab=1)     
text(sigmahat.vals, muhat.vals, labels=names(muhat.vals), pos=1, cex = 1.1)
```

* Starbucks is best, followed by Microsoft and EWYstrom

## Risk-return tradeoff: by year

```{r, echo=FALSE}
muhatByYear = rollapply(projectReturns, width=12, by=12, FUN=mean, align="right")
muhatByYear = na.omit(muhatByYear)

sigmahatByYear = rollapply(projectReturns, width=12, by=12, FUN=sd, align="right")
sigmahatByYear = na.omit(sigmahatByYear)

plot(sigmahat.vals, muhat.vals,  
     ylim=c(-0.02, 0.06), xlim=c(0, 0.20), 
     ylab=expression(mu[p]), xlab=expression(sigma[p]), 
     pch=16, col="blue", cex=1.1, cex.lab=1)     
text(sigmahat.vals, muhat.vals, labels=names(muhat.vals), pos=1, cex = 1.1)

for (i in 1:nrow(muhatByYear)) {
  points(coredata(sigmahatByYear[i, ]), coredata(muhatByYear[i, ]), pch=16, col=i)
  text(coredata(sigmahatByYear[i, ]), coredata(muhatByYear[i, ]), labels=names(muhat.vals), 
         pos=4, cex = 0.5)
}

```

* Big blue circles are full sample estimates
* Small colored circles are values for a particular year
* Risk return tradeoff changes drastically over time!

## 24-month rolling means and volatilities

Use **zoo** function `rollapply()` to compute 24-month rolling means and volatilities

```{r}
roll.muhat.EWS = rollapply(projectReturns[,"EWS"], width=24,
                       FUN=mean, align="right")
roll.sigmahat.EWS = rollapply(projectReturns[,"EWS"],width=24,
                          FUN=sd, align="right")
roll.muhat.EWY = rollapply(projectReturns[,"EWY"], width=24,
                            FUN=mean, align="right")
roll.sigmahat.EWY = rollapply(projectReturns[,"EWY"],width=24,
                               FUN=sd, align="right")
roll.muhat.EWT = rollapply(projectReturns[,"EWT"], width=24,
                            FUN=mean, align="right")
roll.sigmahat.EWT = rollapply(projectReturns[,"EWT"],width=24,
                               FUN=sd, align="right")
roll.muhat.EWH = rollapply(projectReturns[,"EWH"], width=24,
                            FUN=mean, align="right")
roll.sigmahat.EWH = rollapply(projectReturns[,"EWH"],width=24,
                               FUN=sd, align="right")
```

## 24-month rolling means and volatilities

```{r, echo=FALSE}
par(mfrow=c(2,2))
# EWS
  plot.zoo(merge(roll.muhat.EWS, roll.sigmahat.EWS, projectReturns[,"EWS"]), 
          plot.type="single",
          main="EWS",ylab="returns",
          lwd=2, col=c("blue","orange","black"))
  abline(h=0)

 
# EWY
  plot.zoo(merge(roll.muhat.EWY, roll.sigmahat.EWY, projectReturns[,"EWY"]), 
          plot.type="single",
          main="EWY",ylab="returns",
          lwd=2, col=c("blue","orange","black"))
  abline(h=0)  
  
# EWT
  plot.zoo(merge(roll.muhat.EWT,roll.sigmahat.EWT, projectReturns[,"EWT"]), 
          plot.type="single",
          main="EWT",ylab="returns",
          lwd=2, col=c("blue","orange","black"))
  abline(h=0)
  
# EWH
  plot.zoo(merge(roll.muhat.EWH,roll.sigmahat.EWH, projectReturns[,"EWH"]), plot.type="single",
       main="EWH",ylab="returns",
       lwd=2, col=c("blue","orange","black"))
  abline(h=0)
  
# blank
  plot.zoo(roll.muhat.EWS, type="n", ylab="")
  legend(x="center",legend=c("Rolling mean","Rolling sd", "Monthly returns"),
         lwd=2, col=c("blue","orange","black"))
par(mfrow=c(1,1))

```
# 24-month rolling correlations

Here there are three pair-wise correlations: EWS-EWY, EWS-EWT, and EWY-EWT. The following function extracts these pair-wise correlations from the estimated correlation matrix.

```{r}
roll.cor = function(x) {
  cor.hat = cor(x, use = "pairwise.complete.obs")  
  cor.vals = cor.hat[lower.tri(cor.hat, diag = FALSE)]
  
  # Generate proper names for each pair
  tickers <- colnames(x)
  pair_names <- combn(tickers, 2, FUN = function(pair) paste(pair, collapse = "."))
  names(cor.vals) <- pair_names
  
  return(cor.vals)
}

```

Compute all pair-wise 24-month rolling correlations using `rollapply()`

```{r}
roll.cor.vals = rollapply(projectReturns, width=24,
                          by.column=FALSE,
                          FUN=roll.cor, 
                          align="right")
```

## 24-month rolling correlations

```{r}
my.panel <- function(...) {
  lines(...)
  abline(h=0)
}

colnames(roll.cor.vals) <- colnames(roll.cor.vals, do.NULL = FALSE, prefix = "Pair")

# Re-run the plotting function
plot.zoo(roll.cor.vals, panel=my.panel, main="Rolling Pairwise Correlations",
     lwd=2, col="blue", ylim=c(-0.25,1))

```

* Rolling correlations change over time but not too much

## 24-month rolling global minimum variance portfolio

Now we compute the global minimum variance portfolio over 24-month rolling window. First, we need to write a function to return the global minimum variance portfolio weights, means and volatilities for each rolling window. We use the **IntroCompfinR** function `globalMin.portfolio()` to do the calculations.

```{r}
# function to compute rolling global minimum variance portfolios
rollGmin = function(x) {
	mu.hat = colMeans(x)
	cov.hat = var(x)
	gmin = globalMin.portfolio(er=mu.hat,cov.mat=cov.hat)
	ans = c(gmin$er,gmin$sd,gmin$weights)
	names(ans)[1:2] = c("er","sd")
	return(ans)
}
```

Now use `rollapply()` with `rollGmin()` to do the calculations.

```{r}
# use rollapply() to compute rolling portfolios
roll.gmin = rollapply(projectReturns, width=24,
                      by.column=FALSE,align="right",
                      FUN=rollGmin)

# show first three non NA values
na.omit(roll.gmin)[1:3, ]
```

## Global minimum variance portfolio: full sample

```{r}
gmin.full = globalMin.portfolio(er=muhat.vals,cov.mat=cov.mat)
gmin.full
```

* Full sample global minimum variance portfolio is roughly equally weighted

## 24-month rolling global minimum variance portfolio weights

```{r, echo=FALSE}
plot.zoo(roll.gmin[,3:6], main="",
         plot.type="single", col=1:4, lwd=3, ylab="weight")    
abline(h=0)
legend(x="bottomleft", legend=colnames(roll.gmin[,3:6]),
       lty=rep(1,4), col=1:4, lwd=3)
```

* Rolling portfolio weights change a lot over time
* Look at how the weights in Microsoft and Starbucks change over time

## 24-month rolling global minimum variance portfolio weights

```{r, echo=FALSE}
chart.StackedBar(na.omit(roll.gmin[,3:6]))
```

* Stacked bar chart created using the PerformanceAnalytics function `chart.StackedBar()` shows changing weights more clearly

## 24-month rolling global minimum variance portfolio means and volatilities

```{r, echo=FALSE}
plot.zoo(roll.gmin[,1:2],plot.type="single",ylab="percent",
         main="",
         col=c("black","blue"),lwd=3)
abline(h=0)
legend(x="topleft",legend=c("Rolling mean","Rolling sd"),
       lty=rep(1,2),col=c("black","blue"),lwd=3)
```

* Notice how mean and volatility move in opposite directions: when mean goes down vol goes up!

## Efficient portfolio with target return $\mu_p = 0.03$ : Full Sample

```{r}
eport.03 = efficient.portfolio(er=muhat.vals,cov.mat=cov.mat,
                                target.return=0.03)
eport.03

```

Full sample portfolio is a long-short portfol with long positions in Microsoft and Starbucks.

## 24-month rolling efficient portfolios with target return 3%

Now we compute the efficient portfolio with target return 3% over 24-month rolling window. First, we need to write a function to return the efficient portfolio weights, means and volatilities for each rolling window. We use the **IntroCompfinR** function `efficient.portfolio()` to do the calculations.

```{r}
# function to compute rolling efficient portfolios
rollefficient = function(x,target=0.03) {
	mu.hat = colMeans(x)
	cov.hat = var(x)
	eport = efficient.portfolio(er=mu.hat,
                              cov.mat=cov.hat,
	                            target.return=target)
	ans = c(eport$er,eport$sd,eport$weights)
	names(ans)[1:2] = c("er","sd")
	return(ans)
}
```

Now use `rollapply()` with `rollefficient()` to do the calculations.

```{r}
# use rollapply() to compute rolling portfolios
roll.eport = rollapply(projectReturns, width=24,
                       by.column=F,align="right",
                       FUN=rollefficient)
```

## 24-month rolling efficient portfolios

```{r, echo=FALSE}
plot.zoo(roll.eport[,3:6],main="",
     plot.type="single", ylab="weight", col=1:4,lwd=3)
abline(h=0)
legend(x="bottomleft",legend=colnames(projectReturns),
       lty=rep(1,4),col=1:4,lwd=3)
```
## 24-month rolling efficient portfolios

```{r, echo=FALSE}
chart.StackedBar(na.omit(roll.eport[,3:6]))
```

## 24-month rolling global minimum variance portfolio means and volatilities

```{r, echo=FALSE}
plot.zoo(roll.eport[,1:2], plot.type="single", ylab="percent",
         main="", ylim=c(0, 0.35),
         col=c("black","blue"),lwd=3)
abline(h=0)
legend(x="topleft",legend=c("Target er=0.03","Rolling sd"),
       lty=rep(1,2),col=c("black","blue"),lwd=3)

```

## Portfolio Theory

Use all 4 assets and the GWN model estimates computed from the full sample for the following computations. You may find it useful to create a table which summarizes the results from the portfolio calculations for easy reference.

**Using the IntroCompFinR function getPortfolio(), create an equally weighted portfolio of the 4 ETFs and compute the expected return and standard deviation (volatility) of this portfolio**

```{r}
#Create covariance matrix
cov.mat = cov(projectReturns)

#Create equal weighted portfolio
eqw_port = getPortfolio(muhat.vals, cov.mat, c(0.25, 0.25, 0.25, 0.25))
eqw_port
```

**Annualize the the monthly mean and SD by multiplying the mean by 12 and the SD by the square root of 12. Compute the annual Sharpe ratio from these values. Briefly comment on these values relative to those for each asset.**

```{r}
#Compute annual mean and sd for each asset for comparison
muhat.vals_yr = muhat.vals * 12
sd.vals_yr = sd.vals * sqrt(12)
musd_yr = rbind(muhat.vals_yr, sd.vals_yr)
rownames(musd_yr) = c("annual expected mean", "annual std dev")

#Comoute annual mean and sd from equal weight portfolio
mu_eqw_yr = eqw_port[2]$er * 12
sd_eqw_yr = eqw_port[3]$sd * sqrt(12)

#Set up annual risk free rate
rf_annual = 2 / 100

#Compute annual SR
SR_eqw_yr = (mu_eqw_yr - rf_annual) / (sd_eqw_yr)

cat("The annual sharpe ratio of equal weighted portfolio is", SR_eqw_yr)
```

Comparing the annual expect return from the equal weight portfolio to those from the assets, EWS has a expected annual return three times of that of equal weight portfolio with a expected annual standard deviation over three times higher than that of the portfolio. EWY has an annual expected return almost ten times higher than that of the portfolio with an annual standard deviation roughly four times of that of the portfolio. EWT has an annual expected return over four times higher than that of the portfolio with an annual standard deviation over three times than that of portfolio. Lastly, EWH has an annual expected return roughly seven times higher than that of portfolio with an annual standard deviation almost four times higher than that of portfolio.

Overall, we noticed that the portfolio give us a low risk, low return combination option.

**Compute the global minimum variance portfolio and calculate the expected return and SD of this portfolio. Are there any negative weights in the global minimum variance portfolio?**

```{r}
#Calculate global min portfolio with monthly parameters
gm_port = globalMin.portfolio(muhat.vals, cov.mat)
gm_port

barplot_gm <- barplot(gm_port[4]$weights,
        main = " Global Min. Portfolio Weights",
        ylab = "Weight",
        col = "pink",
        border = "purple", ylim = c(-0.4, 0.7))
text(barplot_gm,
     y = gm_port[4]$weights,
     labels = round(gm_port[4]$weights, 3),
     pos = 3, cex = 0.8, col = "black")
```

The global minimum variance portfolio puts negative weight on EWY.

**Annualize the the monthly mean and SD by multiplying the mean by 12 and the SD by the square root of 12. Compute the annual Sharpe ratio from these values. Briefly comment on these values relative to those for each asset.**

```{r}
#Comoute annual mean and sd from global min portfolio
mu_gm_yr = gm_port[2]$er * 12
sd_gm_yr = gm_port[3]$sd * sqrt(12)

#Compute annual SR
SR_gm_yr = (mu_gm_yr - rf_annual) / (sd_gm_yr)

cat("The annual sharpe ratio of equal weighted portfolio is", SR_gm_yr)
```

Comparing the annual expect return from the global minimum variance portfolio to those from the assets, EWS has a expected annual return slightly higher thab that of global minimum vairance portfolio with a expected annual standard deviation over four times higher than that of the portfolio. EWY has an annual expected return almost five times higher than that of the portfolio with an annual standard deviation almost six times of that of the portfolio. EWT has an annual expected return over 22 times higher than that of the portfolio with an annual standard deviation almost five times than that of portfolio. Lastly, EWH has an annual expected return over three times higher than that of portfolio with an annual standard deviation almost five times higher than that of portfolio.

Overall, we noticed that the portfolio give us a low risk, low return combination option.

**Assume that you have $100,000 to invest starting at April 30, 2023. For the global minimum variance portfolio, determine the 1% and 5% normal value-at-risk of the $100,000 investment over a one month investment horizon.  Compare this value to the VaR values for the individual assets.**

```{r}
W = 100000
var_one_gm = W * qnorm(p = 0.01, mean = gm_port[2]$er, sd = gm_port[3]$sd)
var_five_gm = W * qnorm(p = 0.05, mean = gm_port[2]$er, sd = gm_port[3]$sd)
cat("The 1% normal value-at-risk of given investment over one month is", 
    abs(var_one_gm), "\n")
cat("The 5% normal value-at-risk of given investment over one month is", 
    abs(var_five_gm))
```

At 1%, all value-at-risk of assets have higher risk than that of the portfolio.

At 5%, the same applies.

**Using the estimated means, variances and covariances computed earlier, compute and plot the efficient portfolio frontier, allowing for short sales, for the 4 ETFs using the IntroCompFinR function `efficient.frontier()`. Create a plot (based on monthly frequency) with portfolio expected return on the vertical axis and portfolio standard deviation on the horizontal axis showing the efficient portfolios. Indicate the location of the global minimum variance portfolio (with short sales allowed) as well as the locations of your 5 assets and the equally weighted portfolio.**

```{r}
#Compute efficient portfolio frontier using monthly return data
all_eff = efficient.frontier(muhat.vals, cov.mat)
all_eff

#plot the frontier with prevous portfolios
plot(all_eff[3]$sd, all_eff[2]$er, type="b", ylim=c(0, 0.011), xlim=c(0.044, 0.066),
pch=16, col="darkgreen", cex = 1, ylab=expression(mu[p]), xlab=expression(sigma[p]))
text(median(all_eff[3]$sd-0.0027), median(all_eff[2]$er),
labels="Efficient Frontier", pos=1, cex = 0.8, col="darkgreen")
points(gm_port[3]$sd, gm_port[2]$er, cex=1, col="red", cex.lab=1, pch=16)
text(gm_port[3]$sd, gm_port[2]$er,
labels="GM with Short Sell", pos=4, cex=0.8, col="red")
points(eqw_port[3]$sd, eqw_port[2]$er, cex=1, col="blue", cex.lab=1, pch=16)
text(eqw_port[3]$sd, eqw_port[2]$er,
labels="Equal Weight", pos=4, cex=0.8, col="blue")
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[2], muhat.vals[2], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[3], muhat.vals[3], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
text(sd.vals[1], muhat.vals[1],
labels="EWS", pos=4, cex=0.8, col="black")
text(sd.vals[2], muhat.vals[2],
labels="EWY", pos=4, cex=0.8, col="black")
text(sd.vals[3], muhat.vals[3],
labels="EWH", pos=4, cex=0.8, col="black")
text(sd.vals[4], muhat.vals[4],
labels="EWT", pos=4, cex=0.8, col="black")
```

**Find the efficient portfolio with the same mean as the equally weighted portfolio. How much smaller is the volatility of this portfolio compared to the equally weighted portfolio.**

```{r}
#Compute eff portfolio with target mean of mean from the equal weight portfolio
eff_eqwmu = efficient.portfolio(muhat.vals, cov.mat, eqw_port[2]$er)
eff_eqwmu

barplot_gm <- barplot(eff_eqwmu[4]$weights,
        main = " Efficient Portfolio w/ mean from equal weight portfolio Weights",
        ylab = "Weight",
        col = "pink",
        border = "purple", ylim = c(-0.4, 0.7))
text(barplot_gm,
     y = eff_eqwmu[4]$weights,
     labels = round(eff_eqwmu[4]$weights, 3),
     pos = 3, cex = 0.8, col = "black")
```

The standard deviation of this portfolio is 0.0027 smaller than that of the equal weight portfolio.

**Find the efficient portfolio with the same volatility as the equally weighted portfolio. How much larger is the mean of this portfolio compared to the equally weighted portfolio?**

```{r}
#Compute eff portfolio with equal weight portfolio's sd
eff_epwsd_x = eqw_port[3]$sd / eff_eqwmu[3]$sd
eff_epwsd_x * eff_eqwmu[2]$er
```

This portfolio has a expected return 0.00016 higher than that of equal weight portfolio.

**Using the IntroCompFinR function tangency.portfolio() compute the tangency portfolio using a monthly risk free rate equal to 0.00167 per month (which corresponds to an annual rate of 2\% - again, change the number to what makes sense for your chosen sample period). Recall, we need the risk free rate to be smaller than the average return on the global minimum variance portfolio in order to get a nice graph.In the tangency portfolio, are any of the negative weights? Compute the expected return, variance and standard deviation of the tangency portfolio. Compare the Sharpe ratio of the tangency portfolio with those of the individual assets.**

```{r}
#Compute Tangency Portfolio
tan_port = tangency.portfolio(muhat.vals, cov.mat, 0.00167)
tan_port
cat("This portfolio has a vairance of", tan_port[3]$sd^2, "\n")
cat("This portfolio has a sharpe ratio of", 
    (tan_port[2]$er - 0.00167)/tan_port[3]$sd)

barplot_gm <- barplot(tan_port[4]$weights,
        main = "Tangency Portfolio w/ mean T-bill of month return 0.167%",
        ylab = "Weight",
        col = "pink",
        border = "purple", ylim = c(-3, 7))
text(barplot_gm,
     y = tan_port[4]$weights,
     labels = round(tan_port[4]$weights, 3),
     pos = 3, cex = 0.8, col = "black")
```

The sharpe ratio of each asset are all lower than that of the sharpe ratio of the tangent portfolio.

**Annualize the the monthly ER and SD of the tangency portfolio by multiplying the ER by 12 and the SD by the square root of 12. Compute the annual Sharpe ratio from these values. Briefly comment.**

```{r}
tan_mu_yr = tan_port[2]$er * 12
tan_sd_yr = tan_port[3]$sd * sqrt(12)
tan_SR_yr = (tan_mu_yr - 0.02)/tan_sd_yr
cat("The annual expected return of tangency portolio is", tan_mu_yr, "\n")
cat("The annual standard deivation of tangency portolio is", tan_sd_yr, "\n")
cat("The sharpe ratio in annual parameter of tangency portolio is", tan_SR_yr)
```

The annual sharpe ratio is higher than both the annual expected reutn and standard deviation.

**Show the tangency portfolio as well as combinations of T-bills and the tangency portfolio on a plot with the efficient frontier of risky assets.**

```{r}
plot(all_eff[3]$sd, all_eff[2]$er, type="b", ylim=c(0, 0.05), xlim=c(0.044, 0.2),
pch=16, col="darkgreen", cex = 1, ylab=expression(mu[p]), xlab=expression(sigma[p]))
text(median(all_eff[3]$sd-0.0027), median(all_eff[2]$er),
labels="Efficient Frontier", pos=1, cex = 0.8, col="darkgreen")
points(gm_port[3]$sd, gm_port[2]$er, cex=1, col="red", cex.lab=1, pch=16)
text(gm_port[3]$sd, gm_port[2]$er,
labels="GM with Short Sell", pos=4, cex=0.8, col="red")
points(eqw_port[3]$sd, eqw_port[2]$er, cex=1, col="blue", cex.lab=1, pch=16)
text(eqw_port[3]$sd, eqw_port[2]$er,
labels="Equal Weight", pos=4, cex=0.8, col="blue")
points(tan_port[3]$sd, tan_port[2]$er, cex=1, col="purple", cex.lab=1, pch=16)
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[2], muhat.vals[2], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[3], muhat.vals[3], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
text(sd.vals[1], muhat.vals[1],
labels="EWS", pos=4, cex=0.8, col="black")
text(sd.vals[2], muhat.vals[2],
labels="EWY", pos=4, cex=0.8, col="black")
text(sd.vals[3], muhat.vals[3],
labels="EWH", pos=4, cex=0.8, col="black")
text(sd.vals[4], muhat.vals[4],
labels="EWT", pos=4, cex=0.8, col="black")
```


**Using the IntroCompFinR funciton globalMin.portfolio() with optional argument shorts=FALSE, compute the global minimum variance portfolio with the added restriction that short-sales are not allowed, and calculate the expected return and SD of this portfolio.**

```{r}
gm_port_ns = globalMin.portfolio(muhat.vals, cov.mat, shorts = FALSE)
gm_port_ns

barplot_gm <- barplot(gm_port_ns[4]$weights,
        main = "Golbal Min Portfolio with Short Sell Restrictions",
        ylab = "Weight",
        col = "pink",
        border = "purple", ylim = c(0, 0.5))
text(barplot_gm,
     y = gm_port_ns[4]$weights,
     labels = round(gm_port_ns[4]$weights, 3),
     pos = 3, cex = 0.8, col = "black")
```

**Annualize the the monthly estimates by multiplying the ER by 12 and the SD by the square root of 12. Compute the annual Sharpe ratio from these values. Compare this portfolio with the global minimum variance portfolio that allows short-sales.** 

```{r}
mu_gm_ns_yr = gm_port_ns[2]$er * 12
sd_gm_ns_yr = gm_port_ns[3]$sd * sqrt(12)
SR_gm_ns_yr = (mu_gm_ns_yr - 0.02)/sd_gm_ns_yr
cat("The annual expected return of this portolio is", mu_gm_ns_yr, "\n")
cat("The annual standard deivation of this portolio is", sd_gm_ns_yr, "\n")
cat("The sharpe ratio in annual parameter of this portolio is", SR_gm_ns_yr)
```

The annual expected return of global minimum portfolio with short sell is higher than that of the portfolio without short sell. The annual standard deviation of the portfolio with short sell is lower than that of the portfolio without short sell. Lastly, the annual sharpe ratio of the portfolio with short sell is higher than that of the portfolio without short selling.

**Assume that you have $\$100,000$ to invest for a year starting at January 31. For the global minimum variance portfolio with short-sales not allowed, determine the $1\%$ and $5\%$ value-at-risk of the $100,000 investment over a one month investment horizon. Compare your results with those for the global minimum variance that allows short sales.**

```{r}
W = 100000
var_one_gm_ns = W * qnorm(p = 0.01, mean = gm_port_ns[2]$er, 
                          sd = gm_port_ns[3]$sd)
var_five_gm_ns = W * qnorm(p = 0.05, mean = gm_port_ns[2]$er, 
                           sd = gm_port_ns[3]$sd)
cat("The 1% normal value-at-risk of given investment over one month is", 
    abs(var_one_gm_ns), "\n")
cat("The 5% normal value-at-risk of given investment over one month is", 
    abs(var_five_gm_ns))
```

Comparing with those parameters for global minimum variance portfolio with and without short sell, we found those for the portfolio without short sell have higher risk than those for the portfolio with short sell.

**Using the IntroCompFinR function efficient.frontier() with the optional argument shorts=FALSE, compute and plot the efficient portfolio frontier this time not allowing for short sales, for the 5 ETFs.Create a plot (based on monthly frequency) with portfolio expected return on the vertical axis and portfolio standard deviation on the horizontal axis showing the efficient portfolios. Indicate the location of the global minimum variance portfolio (with short sales allowed) as well as the locations of your 5 assets and the equally weighted portfolio.**

```{r}
#Compute efficient portfolio frontier using monthly return data
all_eff_ns = efficient.frontier(muhat.vals, cov.mat, shorts = FALSE)
all_eff_ns

#plot the frontier with prevous portfolios
plot(all_eff_ns[3]$sd, all_eff_ns[2]$er, type="b", ylim=c(0, 0.01), xlim=c(0.04, 0.066),
pch=16, col="darkgreen", cex = 1, ylab=expression(mu[p]), xlab=expression(sigma[p]))
text(median(all_eff_ns[3]$sd-0.0060), median(all_eff_ns[2]$er),
labels="Efficient Frontier without short sell", pos=1, cex = 0.8, col="darkgreen")
points(gm_port_ns[3]$sd, gm_port_ns[2]$er, cex=1, col="red", cex.lab=1, pch=16)
text(gm_port_ns[3]$sd, gm_port_ns[2]$er,
labels="GM without Short Sell", pos=2, cex=0.8, col="red")
points(eqw_port[3]$sd, eqw_port[2]$er, cex=1, col="blue", cex.lab=1, pch=16)
text(eqw_port[3]$sd, eqw_port[2]$er,
labels="Equal Weight", pos=4, cex=0.8, col="blue")
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[2], muhat.vals[2], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[3], muhat.vals[3], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
text(sd.vals[1], muhat.vals[1],
labels="EWS", pos=4, cex=0.8, col="black")
text(sd.vals[2], muhat.vals[2],
labels="EWY", pos=4, cex=0.8, col="black")
text(sd.vals[3], muhat.vals[3],
labels="EWH", pos=4, cex=0.8, col="black")
text(sd.vals[4], muhat.vals[4],
labels="EWT", pos=4, cex=0.8, col="black")
```

**Compare the no short sale frontier with the frontier allowing short sales (plot them on the same graph). The no short sales frontier should be "inside" the frontier allowing for short sales.**

```{r}
plot(all_eff_ns[3]$sd, all_eff_ns[2]$er, type="b", ylim=c(0, 0.01), xlim=c(0.04, 0.06),
pch=16, col="green", cex = 1, ylab=expression(mu[p]), xlab=expression(sigma[p]))
text(median(all_eff_ns[3]$sd+0.0041), median(all_eff_ns[2]$er),
labels="Efficient Frontier without short sell", pos=1, cex = 0.8, col="green")
points(all_eff[3]$sd, all_eff[2]$er, type="b", ylim=c(0, 0.011), xlim=c(0.044, 0.066),
pch=16, col="darkgreen", cex = 1, ylab=expression(mu[p]), xlab=expression(sigma[p]))
text(median(all_eff[3]$sd-0.004), median(all_eff[2]$er),
labels="Efficient Frontier with short sell", pos=1, cex = 0.8, col="darkgreen")
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[2], muhat.vals[2], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[3], muhat.vals[3], cex=1, col="black", cex.lab=1, pch=16)
points(sd.vals[1], muhat.vals[1], cex=1, col="black", cex.lab=1, pch=16)
text(sd.vals[1], muhat.vals[1],
labels="EWS", pos=4, cex=0.8, col="black")
text(sd.vals[2], muhat.vals[2],
labels="EWY", pos=4, cex=0.8, col="black")
text(sd.vals[3], muhat.vals[3],
labels="EWH", pos=4, cex=0.8, col="black")
text(sd.vals[4], muhat.vals[4],
labels="EWT", pos=4, cex=0.8, col="black")
points(eqw_port[3]$sd, eqw_port[2]$er, cex=1, col="blue", cex.lab=1, pch=16)
text(eqw_port[3]$sd, eqw_port[2]$er,
labels="Equal Weight", pos=4, cex=0.8, col="blue")
```

**Consider a portfolio with a target volatility of 0.02 or 2% per month (change this target if it doesn't make sense for your assets). What is the approximate cost in expected return of investing in a no short sale efficient portfolio versus a short sale efficient portfolio?**

```{r}
#Eff Port without ss
eff_eqwmu_ns = efficient.portfolio(muhat.vals, cov.mat, eqw_port[2]$er, shorts = FALSE)

#Cost for without short sell
cost_ns_x = 0.02 / eff_eqwmu_ns[3]$sd
cost_ns = cost_ns_x * eff_eqwmu_ns[2]$er
#Cost for with short sell
cost_x = 0.02 / eff_eqwmu[3]$sd
cost = cost_x * eff_eqwmu[2]$er

cat("If investing 100000, the approximate cost in 
expected return of investing in a no short sell environment is", W * cost - W * cost_ns)
```

**Using a monthly risk free rate equal to 0.00167 per month and the estimated means, variances and covariances compute the tangency portfolio imposing the additional restriction that short-sales are not allowed. Compute the expected return, variance and standard deviation of the tangency portfolio. Give the value of Sharpe's slope for the no-short sales tangency portfolio.**

```{r}
tan_port_ns = tangency.portfolio(muhat.vals, cov.mat, 0.00167, shorts = FALSE)
mu_tan_ns = tan_port_ns[2]$er
sd_tan_ns = tan_port_ns[3]$sd
var_tan_ns = sd_tan_ns^2
SR_tan_ns = (mu_tan_ns - 0.00167) / sd_tan_ns
cat("The expected return of this portolio is", mu_tan_ns, "\n")
cat("The standard deivation of this portolio is", sd_tan_ns, "\n")
cat("The variance of this portolio is", sd_tan_ns, "\n")
cat("The sharpe ratio in month parameter of this portolio is", SR_tan_ns)
```

**Annualize the the monthly ER and SD of the tangency portfolio by multiplying the ER by 12 and the SD by the square root of 12. Compute the annual Sharpe ratio from these values. Briefly comment.**

```{r}
mu_tan_nsyr = mu_tan_ns * 12
sd_tan_nsyr = sd_tan_ns * sqrt(12)
var_tan_nsyr = sd_tan_nsyr^2
SR_tan_nsyr = (mu_tan_nsyr - 0.02) / sd_tan_nsyr
cat("The annual expected return of this portolio is", mu_tan_nsyr, "\n")
cat("The annual standard deivation of this portolio is", sd_tan_nsyr, "\n")
cat("The sharpe ratio in annual parameter of this portolio is", SR_tan_nsyr)
```


## Risk Budgeting

**For the equally weighted portfolio, create a volatility risk report based on an investment of $100,000. Your risk report should be a table with columns for the assets, dollars invested in each asset, allocation weights, MCR, CR, PCR, asset correlation with portfolio, and asset beta with respect to the portfolio. Comment on the risk attribution of the portfolio. Does the risk attribution match the asset allocation? In other words, is there equal risk allocation in the portfolio? Which asset contributes most to the portfolio risk and which asset contributes least?**

```{r RiskBudgeting}
# Equally Weighted Portfolio Risk Analysis
w0 = 100000
eqw.weights = rep(0.25, 4)
d.eqw = w0*eqw.weights
eqw.sd = eqw_port$sd
# fix sigmaport.mat
MCR.eqw = (cov.mat%*%eqw.weights)/eqw.sd
CR.eqw = eqw.weights*MCR.eqw
PCR.eqw = CR.eqw/eqw.sd
Beta.eqw = PCR.eqw/eqw.weights
Rho.eqw = MCR.eqw/eqw.sd
PORT.EQW = c(w0, NA, 1, NA, sum(CR.eqw), sum(PCR.eqw), 1, 1)
eqw.riskreport = cbind(d.eqw, sd.vals, eqw.weights, MCR.eqw, CR.eqw, PCR.eqw, Beta.eqw, Rho.eqw)
eqw.riskreport = rbind(eqw.riskreport, PORT.EQW)
colnames(eqw.riskreport) = c("Dollars", "Vol", "Weight", "MCR", "CR", "PCR", "Beta", "Rho")
eqw.riskreport
```
For the equally weighted portfolio EWY (Korea) contributes the most risk to the portfolio while both EWS (Singapore) and EWH (Hong Kong) contribute the least. Risk is not uniformally distributed between each of the assets of the portfolio, but each of the assets remain relatively close in terms of how much risk they contribute towards the overall portfolio risk. All of the assets are highly correlated with the portfolio as a whole since each of the assets are themselves highly correlated.

## Asset Allocation

**Suppose you wanted to achieve a target expected return of 6% per year (which corresponds to an expected return of 0.5% per month. ** Choose your own sensible target for your portfolio here** ) using only the 5 ETFs and no short sales. What is the efficient portfolio that achieves this target return? How much is invested in each of the Vanguard ETFs in this efficient portfolio?**
```{r}
target_return <- 0.005
monthly_mu <- musd_yr[1,]/12
opt_port <- efficient.portfolio(monthly_mu, cov.mat, target_return, shorts = FALSE)
port_weight <- data.frame(Asset = colnames(projectReturns), Weight = opt_port$weights)
port_weight

```

**Compute the monthly SD on this efficient portfolio, as well as the monthly 1% and 5% value-at-risk based on an initial $100,000 investment.**
```{r}
monthly_sd <- musd_yr [2,]/12
monthly_sd
VaR_1 <- W * (target_return - qnorm(0.99) * monthly_sd)
VaR_5 <- W * (target_return - qnorm(0.95) * monthly_sd)
VaR_1
VaR_5

```

**Suppose you wanted to achieve a target expected return of 6% per year (which corresponds to an expected return of 0.5% per month) using the 5 ETFs and the risk free asset (with monthly return 0.00167), with no short sales of the risky assets. What is the efficient portfolio that achieves this target return? How much is invested in each of the Vanguard ETFs and the risk free asset in this efficient portfolio?**
```{r}
monthly_rf <- 0.00167
excess_mu <- monthly_mu - monthly_rf
port_rf <- efficient.portfolio(excess_mu, cov.mat, target_return - monthly_rf, shorts = FALSE)
weight_risky <- (target_return - monthly_rf) / (t(port_rf$weights) %*% monthly_mu)
weight_rf <- 1 - weight_risky
port_rf_weight <- data.frame(Asset = c(colnames(projectReturns), "Risk-Free"), Weight = c(weight_risky * port_rf$weights, weight_rf))
port_rf_weight
```

\newpage  BELOW are SAMPLE REPORTS you should aim to produce and summarize, but in your in-class presentation, focus on the key lessons and insights with selected tables and figures only

# SAMPLE Executive Summary

The purpose of the analysis to study the statistical behavior of five Vanguard ETFs (4 stock funds and 1 bond fund) and to implement mean-variance portfolio theory to create specific asset allocations among the funds. The data used for the project consists of end-of-month adjusted closing price data from `finance.yahoo.com` over the period Dec 2013 through Dec 2023. The statistical analysis is used to uncover stylized facts of asset behavior and to confirm the application of the GWN model. The estimates of the GWN model are inputs to the mean-variance portfolio theory.

## Stylized Facts

Using graphical and numerical descriptive statistics the following stylized facts of simple monthly returns were observed:

* The best performing asset in terms of 10 year growth is XXX gaining about ##%... 
The best performing asset in terms of 10 year growth is EWT gaining about 116.69%

* Over the full sample, the normal distribution (GWN model) is/isn't a plausible distribution for all returns
Over the full sample, the normal distribution (GWN model) isn't a plausible distribution for all returns

* Returns are correlated/uncorrelated over time. 
Returns are uncorrelated over time. 

* XXX haS the highest monthly mean returns at ##\%. YYY have lower means returns around ##\%. All of the stock ETF have similar monthly volatility around ##\%. The bond ETF has the lowest volatility at ##\%
EWT has the highest monthly mean returns at 0.7952% per month. EWY and EWH have lower means returns around 0.1598% and 0.1172% per month. EWS has the lowest mean returns at 0.0551% per month. EWS, EWT, and EWH have similar monthly volatility around 5.423% per month (mean volatility). The EWS has the lowest volatility at 5.26% per month and the EWY has the highest volatility at 6.46% per month.

* Mean returns and volatilities are/are not estimated very precisely ...etc. 
Mean returns and volatilities are estimated with moderate precision with EWY accounts for highest standard error in both mean returns and volatilities and EWS has the lowest in both.

* From a return-risk perspective, comment on the Sharpe ratios, are they estimated estimated precisely? 
The selected funds all present low Sharpe ratio suggesting poor return to risk performance. EWT has the highest overall Sharpe ratio at 0.1454 and EWS has the lowest Sharpe ratio at 0.0105. The standard error are relatively low with SE/Sharpe Ratio rate at 4.56% ~ 4.57% which suggests that the estimations are precise with minor uncertainty.

* How correlated are the funds? Which one(s) may be more helpful for diversification?
Overall, the funds perform moderate to high positive correlations. However, EWH seems to have relatively lower correlation and therefore it's more helpful for diversification.

* How about their Normal 5\% and 1\% VaR values? Are the Normal VaR is estimated reasonably precisely? Are the Normal VaR and Empirical VaR values similar, supporting the normal distribution?
The normal 5% VaR values range from -3030 to -3840 and normal 1% VaR values range from -1996 to -2568. The normal VaR is estimated reasonably precisely due to its small difference from empirical VaR, with empirical VaR slightly smaller than normal VaR. Since there's small differences the returns may not be perfectly normally distributed.

* Do returns appear to be covariance stationary over the full sample? Do rolling estimates of means show evidence of changing means?  how about rolling volatility estimates?
The returns appear to be covaraince stationary over the full sample.

## Portfolio Theory  

Using the GWN model, the estimated mean vector and covariance matrix of returns were used as inputs to compute a variety of mean-variance efficient portfolios. For retirement portfolios the only feasible portfolios are portfolios that do not allow short sales. A summary of the portfolio results are in the table below

* provide a summary table

```{r}
w.equal <- rep(1/4, 4)
w.minvar <- gm_port[4]$weights
w.tan <- tan_port[4]$weights
w.eff <- eff_eqwmu[4]$weights
w.minvar_ns <- gm_port_ns[4]$weights
w.tan_ns <- tan_port_ns[4]$weights
w.eff_ns <- eff_eqwmu_ns[4]$weights

# Combine weights into a matrix
portfolio.weights <- rbind(
  Equal_Weight = w.equal,
  Minimum_Variance = w.minvar,
  Tangency = w.tan,
  Efficient = w.eff,
  Min_Var_NS = w.minvar_ns,
  Tan_NS = w.tan_ns,
  Eff_NS = w.eff_ns
)

colnames(portfolio.weights) <- c("EWS", "EWY", "EWT", "EWH")

# Calculate portfolio returns and standard deviations
mean.vec <- c(eqw_port[2]$er, gm_port[2]$er, tan_port[2]$er, eff_eqwmu[2]$er,
              gm_port_ns[2]$er, tan_port_ns[2]$er, eff_eqwmu_ns[2]$er)
std.vec <- c(eqw_port[3]$sd, gm_port[3]$sd, tan_port[3]$sd, eff_eqwmu[3]$sd,
             gm_port_ns[3]$sd, tan_port_ns[3]$sd, eff_eqwmu_ns[3]$sd)

# Combine into a summary table
portfolio.summary <- data.frame(
  Expected_Return = round(mean.vec, 4),
  Std_Dev = round(std.vec, 4),
  portfolio.weights
)

# Show table
kable(portfolio.summary, caption = "Portfolio Summary: Expected Returns, Risk, and Weights")
```

* The equal weight portfolio is well inside the efficient frontier of risky assets and has a SR . The risk is spread evenly across the stock ETFs and XXX contributes only ##\% of portfolio risk.

```{r}
w.eq <- rep(1/4, 4)
names(w.eq) <- colnames(projectReturns)

port.var <- t(w.eq) %*% cov.mat %*% w.eq
port.sd <- sqrt(port.var)

mc_eqw <- c(0.012, 0.015, 0.012, 0.12)

risk.contribution <- as.vector(w.eq * mc_eqw)
percent.risk.contribution <- 100 * risk.contribution / port.sd

risk.contrib.table <- data.frame(
  Asset = names(w.eq),
  Risk_Contribution_Pct = round(percent.risk.contribution, 2)
)

kable(risk.contrib.table, caption = "Percentage Contribution to Total Portfolio Risk (Equal Weight Portfolio)")

```


* The unrestricted global minimum variance portfolio is a long-short portfolio with long positions in XXX and short positions in ...  The no-shorts global minimum variance portfolio is ... 

* The efficient frontier allowing for short sales has the classic Markowitz bullet shape. The only fund close to the frontier is XXX, ...etc. The no-shorts efficient frontier lies inside and to the right of the unrestricted frontier and the highest possible target expected return is the mean of XXX.

* The tangency portfolio allowing shorts is a strange long-short portfolio with a large long leveraged position in XXX (wt 2.1) and a large short position in YYY (wt -1.83). The no-short tangency portfolio is 100\% in XXX.   

## Asset Allocation

* The no-shorts efficient portfolio of risky assets that has a target expected return of #\% per year consists of US dividend growth stocks and Municipal bonds: ##\% in XXX and ##\% in YYY. 
```{r}
port_weight
```

* The no-shorts efficient portfolio of risky assets and T-bills is similar: ##% XXX and ##\% T-Bills. 
```{r}
port_rf_weight
```

## Longer-horizon investment

* We also consider one-year investment horizon using the same assets.  Report how your results using annual data differ from above qualitatively. Any insights and lessons?
```{r}
annual_returns <- colMeans(projectReturns, na.rm = TRUE) * 12
annual_sd <- apply(projectReturns, 2, sd, na.rm = TRUE) * sqrt(12)
risk.free.ann <- 0.00167 * 12
annual_sharpe_ratios <- (annual_returns - risk.free.ann) / annual_sd

annual_table <- data.frame(
  Asset = colnames(projectReturns),
  Annual_Return = round(annual_returns, 4),
  Annual_SD = round(annual_sd, 4),
  Annual_Sharpe = round(annual_sharpe_ratios, 4)
)
annual_table
```